package cartographer

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"github.com/gonum/graph/path"
	"github.com/gonum/graph/simple"
	"github.com/twpayne/go-geom"
	"github.com/twpayne/go-geom/xyz"
	"github.com/ulikunitz/xz"
	"io"
	"log"
	"math"
	"os"
	"runtime/debug"
)

// SdeSolarSystems is a slice of structs from the json file
type SdeSolarSystems []struct {
	RegionID        int         `json:"regionID"`
	ConstellationID int         `json:"constellationID"`
	SolarSystemID   int         `json:"solarSystemID"`
	SolarSystemName string      `json:"solarSystemName"`
	X               float64     `json:"x"`
	Y               float64     `json:"y"`
	Z               float64     `json:"z"`
	XMin            float64     `json:"xMin"`
	XMax            float64     `json:"xMax"`
	YMin            float64     `json:"yMin"`
	YMax            float64     `json:"yMax"`
	ZMin            float64     `json:"zMin"`
	ZMax            float64     `json:"zMax"`
	Luminosity      float64     `json:"luminosity"`
	Border          int         `json:"border"`
	Fringe          int         `json:"fringe"`
	Corridor        int         `json:"corridor"`
	Hub             int         `json:"hub"`
	International   int         `json:"international"`
	Regional        int         `json:"regional"`
	Constellation   interface{} `json:"constellation"`
	Security        float64     `json:"security"`
	FactionID       int         `json:"factionID"`
	Radius          float64     `json:"radius"`
	SunTypeID       int         `json:"sunTypeID"`
	SecurityClass   string      `json:"securityClass"`
} // https://sde.zzeve.com/mapSolarSystems.json

//go:embed mapSolarSystems.json.xz
var compressedMapSolarSystems []byte
var mapSolarSystems []byte
var sdeSolarSystems SdeSolarSystems

// SdemapSolarSystemJumps is a slice of structs from the json file
type SdemapSolarSystemJumps []struct {
	FromRegionID        int `json:"fromRegionID"`
	FromConstellationID int `json:"fromConstellationID"`
	FromSolarSystemID   int `json:"fromSolarSystemID"`
	ToSolarSystemID     int `json:"toSolarSystemID"`
	ToConstellationID   int `json:"toConstellationID"`
	ToRegionID          int `json:"toRegionID"`
} // mapSolarSystemJumps.json

//go:embed mapSolarSystemJumps.json.xz
var compressedMapSolarSystemJumps []byte
var mapSolarSystemJumps []byte
var sdeSolarSystemJumps SdemapSolarSystemJumps
var graphMap *simple.DirectedGraph

func init() {
	// setup logging
	log.SetOutput(os.Stdout)
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	var err error

	// Decompress mapSolarSystems
	log.Println("decompressing mapSolarSystems.json.xz")
	r, err := xz.NewReader(bytes.NewReader(compressedMapSolarSystems))
	if err != nil {
		log.Fatalf("Failed to create xz reader: %v", err)
	}

	mapSolarSystems, err = io.ReadAll(r)
	if err != nil {
		log.Fatalf("Failed to read xz compressed data: %v", err)
	}

	// load sdeSolarSystems
	err = json.Unmarshal(mapSolarSystems, &sdeSolarSystems)
	if err != nil {
		// struct was autogenerated, might need type corrections later
		log.Fatalln("problem importing sde, probably a bad type:", err.Error())
	}

	// Decompress mapSolarSystemJumps
	log.Println("decompressing mapSolarSystemJumps.json.xz")
	r, err = xz.NewReader(bytes.NewReader(compressedMapSolarSystemJumps))
	if err != nil {
		log.Fatalf("Failed to create xz reader: %v", err)
	}

	mapSolarSystemJumps, err = io.ReadAll(r)
	if err != nil {
		log.Fatalf("Failed to read xz compressed data: %v", err)
	}

	// load sdeSolarSystemJumps
	err = json.Unmarshal(mapSolarSystemJumps, &sdeSolarSystemJumps)
	if err != nil {
		// struct was autogenerated, might need type corrections later
		log.Fatalln("problem importing sde, probably a bad type:", err.Error())
	}

	// after loading data, initialize graph for pathfinding
	graphMap = createGraphMap()

	// free memory
	log.Println("freeing memory")
	compressedMapSolarSystems = nil
	compressedMapSolarSystemJumps = nil
	mapSolarSystems = nil
	mapSolarSystemJumps = nil
	debug.FreeOSMemory()
}

type System struct {
	ID              int
	Name            string
	RegionID        int
	ConstellationID int
	Security        float64
	JumpDrive       Coordinates
	Route           Route
}

type Route struct {
	Map          *simple.DirectedGraph
	Source, Dest int
}

// coordinate pair for distance calculation
type Coordinates struct {
	CoordA, CoordB geom.Coord
}

// takes meters, returns lightyears as float64
func (c Coordinates) Distance() float64 {
	return xyz.Distance(c.CoordA, c.CoordB) * 0.00000000000000010570
}

// check super range
func (c Coordinates) IsInSuperRange() bool {
	return c.Distance() <= 6
}

// check carrier range
func (c Coordinates) IsInCapitalRange() bool {
	return c.Distance() <= 7
}

// check blops range
func (c Coordinates) IsInBlopsRange() bool {
	return c.Distance() <= 8
}

// check indy range
func (c Coordinates) IsInIndyRange() bool {
	return c.Distance() <= 10
}

// is highsec?
func (s System) IsHighSec() bool {
	return s.Security >= 0.45
}

// is lowsec?
func (s System) IsLowSec() bool {
	return s.Security < 0.45 && s.Security >= 0.05
}

// is nullsec?
func (s System) IsNullSec() bool {
	return s.Security < 0.05 && s.RegionID < 11000001 && s.RegionID != 10000004
}

// https://docs.esi.evetech.net/docs/id_ranges.html

// is wormhole?
func (s System) IsWormhole() bool {
	// regions from 11000000 to 12000000
	return s.ID >= 11000000 && s.ID < 12000000
}

// is pochven?
func (s System) IsPochven() bool {
	// region 11000030
	return s.RegionID == 11000030
}

// is abyssal space?
func (s System) IsAbyssal() bool {
	// regions from 12000000 to 13000000
	return s.RegionID >= 12000000 && s.RegionID < 13000000
}

// gets index of system from sdeSolarSystems for later use
func getSdeMapIndex(id int) int {
	if id == 0 {
		id = 30000142 // just set as Jita so no index error
	}
	for i, v := range sdeSolarSystems {
		if v.SolarSystemID == id {
			return i
		}
	}
	return -1
}

// takes index, returns coordinates
func getGeoCoordinates(system int) geom.Coord {
	// return coordinates
	return geom.Coord{
		sdeSolarSystems[system].X,
		sdeSolarSystems[system].Y,
		sdeSolarSystems[system].Z,
	}
}

// eve navigation method
func EveNavigation(src, dst int) System {
	// todo: remove once Jove space can be supported in mapDenormalize.json
	// https://discord.com/channels/849992399639281694/850326450153324544/1156732565210804305
	if src == 30100000 || dst == 30100000 {
		return System{JumpDrive: Coordinates{
			CoordA: geom.Coord{0, 0, 0},
			CoordB: geom.Coord{999999999999999999999999, 999999999999999999999999, 999999999999999999999999},
		}}
	}

	s := getSdeMapIndex(src)
	d := getSdeMapIndex(dst)
	return System{
		ID:              sdeSolarSystems[d].SolarSystemID,
		Name:            sdeSolarSystems[d].SolarSystemName,
		RegionID:        sdeSolarSystems[d].RegionID,
		ConstellationID: sdeSolarSystems[d].ConstellationID,
		Security:        sdeSolarSystems[d].Security,
		Route: Route{
			Source: src,
			Dest:   dst,
			Map:    graphMap,
		},
		JumpDrive: Coordinates{
			getGeoCoordinates(s),
			getGeoCoordinates(d),
		},
	}
}

// generate a map of all systems with the connected systems
func createGraphMap() *simple.DirectedGraph {
	g := simple.NewDirectedGraph(0, math.Inf(1))

	// add only unique nodes
	for _, v := range sdeSolarSystemJumps {
		for _, vv := range g.Nodes() {
			if vv.ID() == v.FromSolarSystemID {
				goto NEXTNODE
			}
		}
		g.AddNode(simple.Node(v.FromSolarSystemID))
	NEXTNODE:
	}

	// add edges
	for _, v := range sdeSolarSystemJumps {
		// add edges
		g.SetEdge(simple.Edge{
			F: simple.Node(v.FromSolarSystemID),
			T: simple.Node(v.ToSolarSystemID),
			W: 1,
		})
	}

	return g
}

// impl gonum dijkstra search for sdeSolarSystemJumps
func (s System) GetRoute() []int {
	// make path
	p := path.DijkstraFrom(simple.Node(s.Route.Source), s.Route.Map)
	// make slice
	var jumps []int
	gpath, _ := p.To(simple.Node(s.Route.Dest))
	// iterate over path
	for _, v := range gpath {
		jumps = append(jumps, v.ID())
	}
	return jumps
}

// gets route length (jumps) from GetRoute()
func (s System) GetJumps() int {
	// minus one, since we don't count the source system
	return len(s.GetRoute()) - 1
}
